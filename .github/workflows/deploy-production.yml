name: Deploy to Kubernetes

on:
  push:
    branches:
      - main
      - production
    paths:
      - "apps/web/**"
      - "packages/**"
      - "ops/helm/**"
      - "Dockerfile"
      - "apps/web/Dockerfile"
      - ".github/workflows/deploy-production.yml"
  workflow_dispatch: # Allows manual trigger from GitHub UI

env:
  DOCKER_IMAGE_NAME: ignacywie/unchained-web
  HELM_RELEASE_NAME: first
  HELM_CHART_PATH: ./ops/helm/unchained-web
  KUBERNETES_NAMESPACE: default

jobs:
  prisma-sync:
    name: Prisma DB Sync
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20
          cache: "pnpm"

      - name: Install pnpm
        run: npm install -g pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma client
        run: pnpm prisma generate

      - name: Wait for Postgres
        run: |
          echo "‚è≥ Waiting for Postgres..."
          until pg_isready -h ${{ secrets.DB_HOST }} -p ${{ secrets.DB_PORT }} -U ${{ secrets.DB_USER }}; do
            sleep 2
          done
          echo "‚úÖ Postgres is ready"

      - name: Run Prisma DB Push
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: pnpm prisma db push

  build-and-deploy:
    environment: production # Requires approval before running
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout code
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2 # Fetch last 2 commits to detect changes

      # 2. Check what changed (for logging purposes)
      - name: Detect changed files
        id: changes
        run: |
          echo "### Changed Files" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          git diff --name-only HEAD^..HEAD >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          # Check if we should build
          if git diff --name-only HEAD^..HEAD | grep -qE '^(apps/web/|packages/)'; then
            echo "build_needed=true" >> $GITHUB_OUTPUT
            echo "üì¶ Application code changed - building new image" >> $GITHUB_STEP_SUMMARY
          else
            echo "build_needed=false" >> $GITHUB_OUTPUT
            echo "‚ö° Only Helm config changed - skipping build" >> $GITHUB_STEP_SUMMARY
          fi

      # 3. Set up Docker Buildx
      - name: Set up Docker Buildx
        if: steps.changes.outputs.build_needed == 'true'
        uses: docker/setup-buildx-action@v3

      # 4. Login to Docker Hub
      - name: Login to Docker Hub
        if: steps.changes.outputs.build_needed == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 5. Generate image tag (using git SHA)
      - name: Generate image tag
        id: image_tag
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          IMAGE_TAG="${SHORT_SHA}-$(date +%s)"
          echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "full_image=${DOCKER_IMAGE_NAME}:${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "latest_image=${DOCKER_IMAGE_NAME}:latest" >> $GITHUB_OUTPUT

      # 6. Build and push Docker image (only if app code changed)
      - name: Build and push Docker image
        if: steps.changes.outputs.build_needed == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/web/Dockerfile
          push: true
          tags: |
            ${{ steps.image_tag.outputs.full_image }}
            ${{ steps.image_tag.outputs.latest_image }}
          cache-from: type=registry,ref=${{ env.DOCKER_IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_IMAGE_NAME }}:buildcache,mode=max

      # 7. Set up kubectl
      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.28.0"

      # 8. Configure kubectl with kubeconfig
      - name: Configure kubectl
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      # 9. Verify cluster connection
      - name: Verify cluster connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      # 10. Set up Helm
      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: "v3.13.0"

      # 11. Create Helm values file from secrets
      - name: Create Helm values file
        run: |
          # Use new image tag if built, otherwise use existing deployment
          if [ "${{ steps.changes.outputs.build_needed }}" == "true" ]; then
            IMAGE_TAG="${{ steps.image_tag.outputs.tag }}"
          else
            # Get current image tag from deployment
            IMAGE_TAG=$(kubectl get deployment/${{ env.HELM_RELEASE_NAME }}-web -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null | cut -d: -f2 || echo "latest")
            echo "‚ÑπÔ∏è Reusing existing image tag: ${IMAGE_TAG}"
          fi

          cat << EOF > ${{ env.HELM_CHART_PATH }}/values.prod.yaml
          web:
            replicaCount: 2
            image:
              repository: ${{ env.DOCKER_IMAGE_NAME }}
              tag: ${IMAGE_TAG}
              pullPolicy: Always
            service:
              type: ClusterIP
              port: 80
              targetPort: 3000
            env:
              nodeEnv: production

          postgres:
            image:
              repository: postgres
              tag: 15-alpine
            storage:
              size: 1Gi
            service:
              port: 5432

          secrets:
            postgresUser: "${{ secrets.POSTGRES_USER }}"
            postgresPassword: "${{ secrets.POSTGRES_PASSWORD }}"
            postgresDb: "${{ secrets.POSTGRES_DB }}"
            nextAuthSecret: "${{ secrets.NEXTAUTH_SECRET }}"
            nextAuthUrl: "${{ secrets.NEXTAUTH_URL }}"
            aws:
              region: "${{ secrets.AWS_REGION }}"
              smtpUser: "${{ secrets.AWS_SMTP_USER }}"
              smtpPass: "${{ secrets.AWS_SMTP_PASS }}"

          ingress:
            enabled: true
            host: ${{ secrets.INGRESS_HOST }}
            tls:
              clusterIssuer: acme-issuer
          EOF

      # 12. Deploy with Helm
      - name: Deploy to Kubernetes
        run: |
          helm upgrade --install ${{ env.HELM_RELEASE_NAME }} ${{ env.HELM_CHART_PATH }} \
            -f ${{ env.HELM_CHART_PATH }}/values.prod.yaml \
            -n ${{ env.KUBERNETES_NAMESPACE }} \
            --create-namespace \
            --wait \
            --timeout 5m \
            --atomic

      # 13. Verify deployment
      - name: Verify deployment
        run: |
          kubectl rollout status deployment/${{ env.HELM_RELEASE_NAME }}-web -n ${{ env.KUBERNETES_NAMESPACE }}
          kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }} -l component=web

      # 14. Get deployment info
      - name: Get deployment info
        if: success()
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.changes.outputs.build_needed }}" == "true" ]; then
            echo "- **Image Built**: ${{ steps.image_tag.outputs.full_image }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Image**: Reused existing (no app changes)" >> $GITHUB_STEP_SUMMARY
          fi

          echo "- **Release**: ${{ env.HELM_RELEASE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ env.KUBERNETES_NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Pods Status" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }} >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      # 15. Rollback on failure
      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, rolling back..."
          helm rollback ${{ env.HELM_RELEASE_NAME }} -n ${{ env.KUBERNETES_NAMESPACE }}
